package threaded;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.concurrent.*;

public class ThreadedWordCount {
    private Map<String, Integer> wordCount = new ConcurrentHashMap<>();
    
    public Map<String, Integer> countWords(List<String> filePaths, int threadCount) {
        long startTime = System.currentTimeMillis();
        
        int filesPerThread = (int) Math.ceil((double) filePaths.size() / threadCount);
        List<Thread> threads = new ArrayList<>();
        
        for (int i = 0; i < threadCount; i++) {
            int startIndex = i * filesPerThread;
            int endIndex = Math.min(startIndex + filesPerThread, filePaths.size());
            
            if (startIndex >= filePaths.size()) break;
            
            List<String> threadFiles = filePaths.subList(startIndex, endIndex);
            Thread thread = new Thread(() -> {
                for (String filePath : threadFiles) {
                    processFile(filePath);
                }
            });
            threads.add(thread);
            thread.start();
        }
        
        // Wait for all threads to complete
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println(threadCount + " threads execution time: " + (endTime - startTime) + "ms");
        return wordCount;
    }
    
    private void processFile(String filePath) {
        try {
            List<String> lines = Files.readAllLines(Paths.get(filePath));
            for (String line : lines) {
                if (line.trim().isEmpty()) continue;
                
                String cleanedLine = line.toLowerCase()
                    .replaceAll("[^a-zA-Z\\s]", "")
                    .trim();
                
                String[] words = cleanedLine.split("\\s+");
                for (String word : words) {
                    if (!word.isEmpty()) {
                        wordCount.merge(word, 1, Integer::sum);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

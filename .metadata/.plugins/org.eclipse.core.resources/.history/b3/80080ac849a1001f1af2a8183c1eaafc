package main;

import threaded.ThreadedWordCount;
import threadpool.ThreadpoolWordCount;
import unthreaded.UnthreadedWordCount;

import java.io.File;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        // Get list of files from the directory containing Dracula text files
        String directoryPath = "C:\\Users\\Devyanii\\Desktop\\JAVA\\A8\\Assignment8\\Assignment8\\";
        List<String> filePaths = getFilePaths(directoryPath);
        
        // Debug information
        System.out.println("Scanning directory: " + directoryPath);
        File dir = new File(directoryPath);
        System.out.println("Directory exists: " + dir.exists());
        System.out.println("Is directory: " + dir.isDirectory());
        File[] allFiles = dir.listFiles();
        if (allFiles != null) {
            System.out.println("Total files found: " + allFiles.length);
            System.out.println("Files in directory:");
            for (File file : allFiles) {
                System.out.println(" - " + file.getName());
            }
        }
        
        if (filePaths.isEmpty()) {
            System.err.println("No text files found in the directory!");
            return;
        }
        
        // Print system information
        int processors = Runtime.getRuntime().availableProcessors();
        System.out.println("\nAvailable processors: " + processors);
        System.out.println("Number of files to process: " + filePaths.size());
        System.out.println("\n--- Starting Word Count Comparisons ---\n");
        
        // Run unthreaded version
        System.out.println("Running unthreaded version:");
        UnthreadedWordCount unthreaded = new UnthreadedWordCount();
        Map<String, Integer> result1 = unthreaded.countWords(filePaths);
        printTopWords(result1, 10);
        
        System.out.println("\nRunning threaded versions:");
        ThreadedWordCount threaded = new ThreadedWordCount();
        // Test with different thread counts
        int[] threadCounts = {2, 5, 10, 15, 20};
        for (int threadCount : threadCounts) {
            System.out.println("\nTesting with " + threadCount + " threads:");
            Map<String, Integer> result2 = threaded.countWords(filePaths, threadCount);
            // Verify results match unthreaded version
            if (!compareResults(result1, result2)) {
                System.out.println("WARNING: Results differ from unthreaded version!");
            }
        }
        
        System.out.println("\nRunning thread pool version:");
        ThreadpoolWordCount threadpool = new ThreadpoolWordCount();
        Map<String, Integer> result3 = threadpool.countWords(filePaths);
        // Verify results match unthreaded version
        if (!compareResults(result1, result3)) {
            System.out.println("WARNING: Results differ from unthreaded version!");
        }
    }
    
    private static List<String> getFilePaths(String directoryPath) {
        File directory = new File(directoryPath);
        List<String> filePaths = new ArrayList<>();
        
        if (directory.exists() && directory.isDirectory()) {
            // First try to find files with specific naming pattern (dracula1.txt, dracula2.txt, etc.)
            for (int i = 1; i <= 20; i++) {
                File file = new File(directory, "dracula" + i + ".txt");
                if (file.exists()) {
                    filePaths.add(file.getAbsolutePath());
                }
            }
            
            // If no files found with numbered pattern, try to find any .txt files
            if (filePaths.isEmpty()) {
                File[] files = directory.listFiles((dir, name) -> 
                    name.toLowerCase().endsWith(".txt") && 
                    (name.toLowerCase().contains("dracula") || name.toLowerCase().contains("drac"))
                );
                if (files != null) {
                    for (File file : files) {
                        filePaths.add(file.getAbsolutePath());
                    }
                }
            }
        } else {
            System.err.println("Directory not found or is not a directory: " + directoryPath);
            System.err.println("Absolute path: " + directory.getAbsolutePath());
        }
        
        // Sort the files to ensure consistent ordering
        Collections.sort(filePaths);
        return filePaths;
    }
    
    private static void printTopWords(Map<String, Integer> wordCount, int topN) {
        System.out.println("\nTop " + topN + " most frequent words:");
        wordCount.entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .limit(topN)
            .forEach(entry -> System.out.printf("%-20s: %d%n", entry.getKey(), entry.getValue()));
    }
    
    private static boolean compareResults(Map<String, Integer> map1, Map<String, Integer> map2) {
        if (map1.size() != map2.size()) return false;
        return map1.entrySet().stream()
            .allMatch(e -> e.getValue().equals(map2.get(e.getKey())));
    }
}